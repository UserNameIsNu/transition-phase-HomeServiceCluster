[TOC]



# 1，背景与目标

## 1.要干嘛的

丢在家庭网络下的服务集群。

在不依赖云厂商的前提下，通过公网IPv6地址与买来的域名，实现集群部署。

## 2.为啥不用现成的

云厂商太™贵了。

可怜的双核4G配个位数MB的环境要每月几百。

尤其想扩数据传输量，更是单独收费，贵的吓人。

要是换用内网穿透，也是单独收费。

反正都是要钱如催命。

在家折腾一个集群，用家里光猫现成的公网地址，家里套餐自带的带宽，自己的电脑。

便宜好几倍，又方便。

尤其公司只能干某一块的活，我这相当于一个人负责整个项目全流程的设计与构建。

可以不做，不熟。

但至少要知道分工咋分，各自干嘛，什么东西必须要，什么东西没必要。

就当作为对微服务架构、网络部署与系统设计的实践与学习。

在学校敲xx系统或进公司curd都学不到这些的。

## 3.目标成啥样

丢自己项目上去展示。

丢自己项目上去自用。

方便管理电脑膨胀的没边的文件。

就是包括Web应用，文件存储，AI服务，身份认证，日志监控等多个独立服务。

类似简化微服务架构。

# 2，设计原则

## 1.服务独立部署

就是使劲拆。

把单体复杂系统干成多个独立，单独启动，单独崩溃，单独修改的形式。

不拆？

改点啥全部重启，不知道牵扯到啥玩意，所有东西绑死。

小项目还好，大起来就是纯纯堆史山。

目前就按照不同的Web应用，服务进行拆分。

Web应用和服务里面爱拆不拆，每个玩意大不到哪里去。

要拆也行，这不有微服务这个老大哥做现成的参考嘛。

## 2.入口统一，内部解耦

对外只有一个入口，就像整体。

内部就是一大帮子小家伙各干各的，分工合作。

免得每个家伙都要独立管理域名，证书，安全，监控啥的。

公网只认caddy，服务只靠端口在内部交流。

## 3.协议优先于实现

就是一开始设计就绕着全部独立，靠http之类的交流。

定义接口，请求格式，返回结构啥的。

只认这套沟通协议，不管项目或服务自身是啥语言写的。

## 4.本地优先，公网可达

集群在自己的私人设备中运行。

数据也在本地。

公网是访问方式，不是生存条件。

断网，炸域名啥的都不影响。

## 5.自动化优于人工配置

能自动化，能配置的就不要人工手动折腾。

如证书管理和内网转发交给caddy。

项目某些属性使用配置值而不要写死在文件中。

## 6.数据访问限制

1. 应用层不可直接访问数据层，必须经由服务层的访问服务。
2. 应用层调用服务时仅允许基础单表操作，禁止复杂或跨表操作。
3. 服务层任何服务在需要访问数据层时均直连，不能出现服务调用服务。
4. 服务层直连时允许任意操作。
5. 应用层需要复杂操作时，拆分为多次简单操作，在应用层拼接使用。
6. 服务层不能返回空，就算是没有结果甚至报错也必须封装进统一响应对象中返回。
7. 应用层拼装的结果只能用于自身业务，不能将拼装结果作为参数反向写回访问服务。

# 3，图

## 1.网络拓扑

![网络拓扑图](.\网络拓扑图.png)

## 2.服务架构

![服务架构图](.\服务架构图.png)

# 4，服务设计

## 1.逻辑分层

- 接入层
  - Caddy
- 应用层
  - Web应用
  - 家庭存储
- 服务层
  - 邮件与短信提醒
  - 数据库访问
  - 文件系统访问
  - 大模型API接入
  - 流式传输
- 数据层
  - MySQL
  - Redis
  - 文件系统
- 跨层
  - 接入-应用
    - 身份与访问控制
    - 出入站监控记录
  - 应用-服务
    - 可用服务注册与路由
  - 接入-应用-服务
    - 日志

## 2.交互规范

所有服务或应用间交流必须使用HTTP。

状态码仅表示通信状态，不能是错误码。

包含：

- 响应状态
- 状态码
- 响应消息
- 数据
- 追踪ID（请求在集群中流动的身份证，不管去到哪里，都能组成完整链路）

```json
{
  "success": true,
  "code": "OK",
  "message": "",
  "data": {
      ...
  },
  "traceId": ""
}
```

## 3.服务默认搭建规范

使用SpringBoot。

项目结构统一。

```
src
 ├─ api
 ├─ app
 ├─ domain
 ├─ infra
 ├─ config
 └─ bootstrap
```

- api

  - 定义这个服务能干嘛。

  - 以借书业务举例。

  - 借书就需要谁借哪本书，再返回响应。

  - ```
    POST /borrow
    ```

  - ```java
    class BorrowRequest {
        Long userId;
        Long bookId;
    }
    
    class BorrowResult {
        boolean success;
        String message;
    }
    ```

- app

  - 定义事件发生了那些步骤。

  - 建立对象啦，条件判断啦，返回结果啦。

  - 就是不做逻辑处理，做逻辑编排。

  - ```java
    public class BorrowApplicationService {
    
        public BorrowResult borrow(Long userId, Long bookId) {
            // 获取用户
            User user = userQuery.getUser(userId);
            // 用户存不存在
            List<BorrowRecord> records =
                borrowQuery.findUnreturnedByUser(userId);
            // 获取书籍
            Book book = bookQuery.getBook(bookId);
    
            // 判断一些条件
            Borrow borrow =
                Borrow.create(user, book, records);
    
            borrowRepo.save(borrow);
            bookRepo.markBorrowed(bookId);
    
            // 返回结果
            return BorrowResult.success();
        }
    }
    ```

- domain

  - 定义事件需要的判断。

  - 相当于逻辑块？给app拼装用的。

  - ```java
    public class Borrow {
    
        public static Borrow create(
            User user,
            Book book,
            List<BorrowRecord> records
        ) {
            if (user == null) {
                throw new DomainException("用户不存在");
            }
    
            if (!records.isEmpty()) {
                throw new DomainException("有未归还图书");
            }
    
            if (!book.isAvailable()) {
                throw new DomainException("图书不可借");
            }
    
            return new Borrow(user.getId(), book.getId(), now());
        }
    }
    ```

- infra

  - 脏活累活。

  - 如实际的数据库操作，语句编写，逻辑细节之类的丢进来。

  - ```java
    class BookRepositoryImpl implements BookRepository {
        public Book findById(Long id) {
            // SQL
        }
    
        public void markBorrowed(Long id) {
            // update book set status='BORROWED'
        }
    }
    ```

- config

  - 就是服务的配置。

- bootstrap

  - 服务的启动点，初始化任务，环境检查，监听等玩意。

注意！

其中api中的变化必须是业务需求有变才变，数据库变的它不用变。

而infra中的变化跟业务需求无关，数据库变了他就变。

- 变api（改规则）
  - 借书需要押金了
  - 借书失败要返回原因了
  - 支持批量借书了

- 变infra（修机器）
  - 查询更快了
  - 用了新索引
  - SQL 重写